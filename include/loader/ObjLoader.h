/**
 * @file ObjLoader.h
 * @author Ryan Purse
 * @date 23/02/2022
 */


#pragma once

#include <functional>
#include "MeshComponents.h"
#include "MtlLoader.h"

typedef std::function<void(const ObjVertex&)> GenVertexSignature;
typedef std::function<uint32_t()> GetSizeSignature;
typedef std::function<std::vector<std::string>(std::string_view)> MtlDelegateSignature;

/**
 * @brief Generates a mesh based on an .obj file.
 * @param path - The path to the .obj file that you want to load.
 * @param genVertexDelegate - How you want to deal with vertex information from the file.
 * @param getSizeDelegate - Helper function to tell the function the number of vertices.
 * @returns The indices generated by the file.
 */
[[nodiscard]] std::vector<uint32_t>
parseObj(std::string_view path, const GenVertexSignature &genVertexDelegate, const GetSizeSignature &getSizeDelegate,
         const MtlDelegateSignature &loadMtlDelegate);

/**
 * @brief Creates a shared mesh with the specified vertex type.
 * @tparam VertexSpecification - The vertex spec that you want.
 * @param path - The path to the .obj file
 * @returns A shared mesh that can be used by the program.
 */
template<typename VertexSpecification, typename MaterialSpecification>
SharedMesh loadObj(std::string_view path)
{
    std::vector<VertexSpecification> vertices;
    std::vector<MaterialSpecification> materials;
    
    const auto genVertex = [&vertices](const ObjVertex &objVertex) {
        vertices.emplace_back(objVertex);
    };
    
    const auto getSize = [&vertices]() {
        return static_cast<uint32_t>(vertices.size());
    };
    
    const auto loadMtlDelegate = [&](std::string_view materialPath) {
        const auto [names, mat] = loadMtl<MaterialSpecification>(convertRelativePath(path, materialPath));
        materials = mat;
        return std::move(names);
    };
    
    return std::make_shared<Mesh<VertexSpecification>>(
            std::move(vertices),
            std::move(parseObj(path, genVertex, getSize, loadMtlDelegate))
    );
}

